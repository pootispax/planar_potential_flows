\newpage
\section{Functional requirement of the program}
\subsection{The project}
The goal of this project is to simulate the movement of a fluid through
different geometries. The program creates a box of a choosen size, builds a
geometry inside it and simulates the movement of a given fluid.

\subsection{Files}
In order to increase readability, the project is made of several files.
I made the choice to work with Object Oriented Programming.
\begin{itemize}
      \item main.py: This file calls for the needed functions/class
      \item matrices.py: This file contains the class ``Matrices'', it builds
            the geometry, the different matrices to plot and stores them
      \item plot.py: This file plots the matrices built in ``matrices.py''
      \item parameters.py: This file contains all the variables that can be 
          changed by the user
      \item data\_check.py: This file checks the variables and makes sure that
          the program will run
\end{itemize}

\subsection{Data}
This project uses several piece of data set by the user to work.
\begin{itemize}
      \item \py{Nx:} \textcolor{dtype}{\py{uint}} and
            \py{Ny:} \textcolor{dtype}{\py{uint}}, size of the domain
      \item \py{h:} \textcolor{dtype}{\py{uint}}, size of a cell
      \item \py{geometry: str}, choosen geometry
      \item \py{angle:} \textcolor{dtype}{uint}, angle of the
            widening/shrinkage geometry
      \item \py{vx: float}, initial fluid speed (Neuman's condition)
      \item \py{phi_ref: float}, reference velocity potential (Dirichlet's
            condition)
      \item \py{rho: float}, relative density of the fluid
      \item \py{pressure_init: float}, initial pressure of the fluid
\end{itemize}
Be careful in the case of a widening/shrinkage geometry!
In order for the program to generate a domain from one end to another, there is
a restriction on the angle, if the restriction is not met, the program will
output a ValueError. The restriction is as follows:
\[
      |angle| < \arctan{\left(\dfrac{0.5 \times N_y - 1}{N_x}\right)}
\]
The angle parameter should be set in degree, the program will convert it to
radians for the computation.

\subsection{Outputs}
As of the alpha version, the program outputs 4 pdf files, one for each plot.
The files are saved in a subfolder named \textbf{figures/} and the filenames
are set with the following rule:\\
\begin{center}
      \mintinline{python}{<data>_<geometry>_Nx=<Nx>_Ny=<Ny>.pdf}
\end{center}
\mintinline{python}{data} stands for the plotted data (potential, velocity,
streamlines, pressure).
\subsection{Concerning the running time}
Due to the function \py{numpy.linalg.solve()} being slow for
big matrices, the bigger the size of the domain, the higher the running time.\\
For a domain size of $\num{3600}$ cells ($\num{60} \times \num{60}$), it takes
around $\num{20}$ seconds to run, for a domain size of $\num{14400}$ cells
($\num{120} \times \num{120}$), it increases to $\num{23}$ minuts. 
\smallbreak{}
I searched for a faster method to solve the linear system in vain, thus I
recommend to stay on relatively low values for $N_x$ and $N_y$, the graphs are
easily readable for a value of $\num{60}$ each.\\

\section{Internal structure of the program}
\subsection{Physical model}
In order to build the model, the program uses a squared structured lattice
model (matrix). The values are computed at each point of the matrix.

\subsection{Scientific computation algorithms}


\subsection{Constitutive elements}
\subsubsection{\py{main.py}}
This file is executable (without parameters input in the command).\\
After the imports, it will first call the file \py{check_data.py} to check the
type of the input data.\\
Then it will call the file \py{matrices.py} to initiate
the values of \py{G}, \py{M}, \py{cell_coords}, \py{A} and \py{b}.
\smallbreak{}
It then checks for the \py{recompute} value, if \py{True} or if there are no
existing \textbf{dat} files for the current parameters, it will call
the function \py{domain_check()} to display a warning if the domain is large.
It then calls the subroutine \py{make_data()} to compute \py{phi},
\py{grad_x}, \py{grad_y}, \py{grad_norm} and \py{pressure} and saves them in
\textbf{dat} files.\\
Else, it will use the existing dat files to generate the plots.
\smallbreak{}
Then it calls the function \py{load_data()} to read the \textbf{dat} files and
stores them in a dictionary and it initiate the file \py{plot.py} which will be
used to plot the different values.
\smallbreak{}
The last lines call the subroutine \py{plot_graphs} with different arguments
to plot and save all the wanted graphs.

\subsubsection{\py{data_check.py}}
This file has several subroutines and functions to rule the execution of the
program.
\smallbreak{}
The subroutine \py{data_check()} reads the value of each parameter and checks
that the type and the value are correct and will not cause a crash of the
program. If the value/type is incorrect, it will raise an error and stop the
program.
\smallbreak{}
The function \py{existing_data()} will check for specific files in the
\textbf{dat/} subfolder. If at least one files is missing, it returns \py{True}
and the program will recompute all the data. Else it does nothing.
\smallbreak{}
The subroutine \py{domain_check()} is just a warning. It read the max value of
the matrix \py{M} plus one which is the number of fluid cells to compute.
If this number is higher than 5000, it will display a message warning the user
that the program can take some time to run. Then it asks if the user wants to
keep going. \py{"Yes"} will continue, \py{"No"} will stop the program and
anything other than that will stop the program aswell.

\subsubsection{\py{matrices.py}}
This class is where everything is computed, from start to end.
\smallbreak{}
\py{__init__} stores the value of \py{G}, \py{M}, \py{cell_coords}, \py{b} and
\py{A} which will be used several times in the class.
\smallbreak{}
The subroutine \py{make_data{}} will call the functions that compute \py{phi},
\py{grax_x}, \py{grad_y}, \py{grad_norm} and \py{pressure}. Each function
will write the data in a \textbf{dat} file.
\smallbreak{}
The function \py{load_data()} reads the \textbf{dat} files and return the
values in a dictionary.
\smallbreak{}
The function \py{build_g()} takes 4 input arguments.
\begin{itemize}
      \item \py{Nx: int}
      \item \py{Ny: int}
      \item \py{geometry: str}
      \item \py{angle: int} of size 8 bits, in radians
\end{itemize}
It acts as a selector. Given a geometry, it will create a matrix \py{G} filled
with zeros and call the function \py{build_geometry()} with different input
values. There is no real point in this function in the alpha version since the
straight, widening and shrinkage geometries are generated from the same
function, with only the angle changing. However, it will prove useful in the
beta and gold version.
\smallbreak{}
The function \py{build_geometry()} takes 2 input arguments.
\begin{itemize}
      \item \py{G:} \textcolor{dtype}{\py{np.array}}
      \item \py{angle: int} of size 8 bits, in radians
\end{itemize}
The function returns the matrix \py{G}.\\
The function starts by computing \py{alpha} as the tangent of the angle.\\
It then uses it in a \py{for} loop to compute an offset which will be used to
build the geometry.\\
In case of a shrinkage geometry, the angle inputed is negative, the function
will flip horizontally the matrix. It then sets the inlet and outlet of the
domain.\\
Since the program will always compute \py{G} no matter what and to avoid some
problem, it will save the matrix only if \py{recompte == True}.
\smallbreak{}
The function \py{build_index_matrices()} takes 2 input arguments.
\begin{itemize}
      \item \py{Nx: int}
      \item \py{Ny: int} 
\end{itemize}
The function returns the matrix \py{M} and the array \py{cell_coords}.\\
It starts by creating the matrix \py{M} the shape of \py{G}, filled with zeros
and initiate a counter \py{count}. It then parses \py{M} and for each fluid
cell (\py{G[c, r] != 0}), it sets the value of \py{M[r, c]} to the value of the
counter and increment the counter by 1. All the other values are set to -1.\\
Then it create an array \py{cell_coords} of size \py{(M.max() + 1, 2)} and
sets the value of the counter back to zero. Then it parses the matrix \py{M}
and for each cell which value is not -1, it will store the coordinates of that
cell in the index \py{count} of the array \py{cell_coords} and increment the
counter.
\smallbreak{}
The function \py{build_a()} takes no input, it uses the imported data from
\py{parameters.py}.\\
The function returns the matrix \py{A}.\\
It starts by creating an array \py{A} of size
\py{(cell_coords.shape[0], cell_coords.shape[0])}, filled with zeros. It then
parses the array \py{cell_coords} and for each inlet and fluid cell (the oulet
is not counted there), it counts the neighbors, stores their coordinates,
set the value of the diagonal depending on the neighbors and sets each
neighbour associated cell to 1. The diagonal cells corresponding to the outlet
are all set to 1.
\smallbreak{}
The function \py{build_b()} takes no input, it uses the imported data from
\py{parameters.py}.\\
It returns the array \py{b}.\\
It starts by creating an array \py{b} of size
\py{(cell_coords.shape[0], 1)}, filled with zeros.\\
It then parses the array. For each cell corresponding to the inlet, it sets the
value to \py{-vx * h} and for each value corresponding to the outlet, it sets
the value to \py{phi_ref}. The rest of the array is not modified.
\smallbreak{}
The function \py{build_phi()} takes no input, it uses the imported data from
\py{parameters.py}.\\
This function is the slowest one since it compute the solution of $Ax = b$. For
that it uses the function \py{linalg.solve()} from \py{numpy}. Then it creates
an empty matrix \py{phi} and fills it with \py{numpy.nan}. It then parses
\py{x} and sets the value of each phi cell corresponding to the \py{x} value.
The other cells are not modified.\\
Finally, it saves the values in a \textbf{dat} file.
\smallbreak{}
The function \py{build_gradient()} takes no input, it uses the imported data
from \py{parameters.py}.\\
This function is rather big, but it is only a variation of the \py{gradient}
function from \py{numpy}. The function \py{numpy.gradient} does not work
the way I want with the \py{numpy.nan} values so I made my own.\\
It starts by loading the \textbf{dat} file containing the values of \py{phi}
and creates 2 empty matrices \py{grad_x} and \py{grad_y} the same shape as
\py{G} and fills them with \py{numpy.nan}. It the parse the \py{cell_coords}
array and sets the values of \py{grad_x} and \py{grad_y} following the centered
difference with step $2h$ mentioned in the scope statement. I then found that
the function \py{numpy.gradient} uses the same method. However, since the
borders of the matrix \py{phi} is filled with \py{numpy.nan} values, the
gradient is not computed at the outer edge of the domain.\\
To compute there values, I applied the impermeable wall condition specified in
the section \textbf{5.1} of the scope statement. We consider the 
\py{numpy.nan} cell with coordinates \py{[i - 1, j]} as a fictious cell with
the value of the cell \py{[i, j]}. This rule applies to the cells to the left
and to the right for \py{grad_x} and to the top and to the right for
\py{grad_y}.\\
It the computes the norm of the gradient (used later to plot the normalized
gradient).\\
Finally, it saves the 3 matrices in \textbf{dat} files.
\smallbreak{}
The function \py{build_pressure()} takes no input, it uses the imported data
from \py{parameters.py}.\\
The function starts by loading the \textbf{dat} files containing the values of
\py{grad_norm}.\\
It then creates an empty matrix \py{pressure} and fills it with \py{numpy.nan}.
Then, it computes the Bernoulli's constant $\mathcal{H}$ using the initial
values.\\
It then parses the array \py{cell_coords}, sets the inlet cells of the
\py{pressure} matrix to \py{pressure_init}, computes and sets the values for
each cell.\\
Finally, it saves the matrix in a \textbf{dat} file.

\subsubsection{\py{plot.py}}
The class is used to plot every piece of data.
\smallbreak{}
The function \py{plot_graphs()} takes 2 input arguments.
\begin{itemize}
      \item \py{display: str}
      \item \py{data: dict}
\end{itemize}
This subroutine creates the figure, shows the matrix \py{G} (without
interpolation) and disables the axes as they are not needed in that kind of
plot. Then, depending on the \py{display} value, it will call other 
functions to plot the graphs and save them as \textbf{pdf} files.
\smallbreak{}
Each one of the 4 next functions take 1 input argument.
\begin{itemize}
      \item \py{data: dict}
\end{itemize}
They return the plotted graph.\\
The 4 functions work the same way, they set the name of the graph and plot the
desired data.